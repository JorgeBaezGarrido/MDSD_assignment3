/*
 * generated by Xtext 2.21.0
 */
package mdsd.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import javax.swing.JOptionPane
import mdsd.mathCompiler.Plus
import mdsd.mathCompiler.Minus
import mdsd.mathCompiler.Mult
import mdsd.mathCompiler.Div
import mdsd.mathCompiler.Expression
import mdsd.mathCompiler.External
import mdsd.mathCompiler.Num
import java.util.HashMap
import java.util.Map
import mdsd.mathCompiler.Var
import mdsd.mathCompiler.Let
import mdsd.mathCompiler.MathExp
import mdsd.mathCompiler.Expressions


/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathCompilerGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val maths = resource.allContents.filter(Expressions).next;
		
		//Interpreter
		maths.getExpressions();
		maths.computeExpressions
		
		System.out.println("-----------------------------------------------------------------")
		
		//Generator
		System.out.println(maths.expression)
		fsa.generateFile("MathCompiler.java", maths.generateMath)
	}
	
	
	def CharSequence generateMath(Expressions exp){
		'''
		import java.util.*;
		
		public class MathCompiler {
			
			«IF exp.checkExternal»
				«externalWrite»
			«ELSE»
			public MathCompiler(){
			}
			«ENDIF»	
		
					
			public void compute(){
				«exp.getExpression»
			}
			
			public static void main(String args[]){
				MathCompiler mc = new Match
			}	
		}
		'''
	}
	
	/**
	 * Will add all the expressions written into the compute() method in the generated java file.
	 */
	def String getExpression(Expressions exp){
		var complete_expression = ""
		for (MathExp math : exp.expressions){
			var soutString = "System.out.println(" + math.line + "+" + math.display  + ");\n"
			complete_expression += soutString		
		}
		return complete_expression
	}
	
	/**
	 * Checks for if an external has been given by a user.
	 */
	def boolean checkExternal(Expressions exp) {
		for (MathExp math : exp.expressions){
			if (math.exp instanceof External){
				return true
			}			
		}
		return false
	}
	
	/**
	 * Will put external function power into the java file.
	 */
	def externalWrite()'''
	public static interface Externals {
		public int power(int base, int exponent);
	}
	private External external;
				
	
	public MathCompiler(External _external){
		external = _external;
	}
	'''
	
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	
	/**
	 * Interpreter code from here.
	 */
	 
	def int computeExpressions(Expressions exp){
		for (MathExp math : exp.expressions){
			val result = math.compute
			System.out.println("Math expression = "+math.display)
			JOptionPane.showMessageDialog(null, "result = "+result,"Math Language", JOptionPane.INFORMATION_MESSAGE)
			
		}
		 0 //throw new Error("No Expressions given")
	}
	
	def int compute(MathExp math) { 
		math.exp.computeExp(new HashMap<String,Integer>)
	}
	
	def int computeExp(Expression exp, Map<String,Integer> env) {
		switch exp {
			Plus: exp.left.computeExp(env)+exp.right.computeExp(env)
			Minus: exp.left.computeExp(env)-exp.right.computeExp(env)
			Mult: exp.left.computeExp(env)*exp.right.computeExp(env)
			Div: exp.left.computeExp(env)/exp.right.computeExp(env)
			Num: exp.value
			Var: env.get(exp.id)
			External: {
				var temp = exp.base
				for(var i=1; i < exp.exponent; i++){
					temp = temp*exp.base
				}
				temp
			}
			Let: exp.body.computeExp(env.bind(exp.id,exp.binding.computeExp(env)))
			default: throw new Error("Invalid expression")
		}
	}
	
	def Map<String, Integer> bind(Map<String, Integer> env1, String name, int value) {
		val env2 = new HashMap<String,Integer>(env1)
		env2.put(name,value)
		env2 
	}

	//
	// Display function: show complete syntax tree
	// Note: written according to illegal left-recursive grammar, requires fix
	//

	def String display(MathExp math) { 
		math.exp.displayExp
	}
	
	def String displayExp(Expression exp) {
		"("+switch exp {
			Plus: exp.left.displayExp+"+"+exp.right.displayExp
			Minus: exp.left.displayExp+"-"+exp.right.displayExp
			Mult: exp.left.displayExp+"*"+exp.right.displayExp
			Div: exp.left.displayExp+"/"+exp.right.displayExp
			Num: Integer.toString(exp.value)
			Var: exp.id
			External: "externals.power("+exp.base+","+exp.exponent+")"			
			Let: '''let «exp.id» = «exp.binding.displayExp» in «exp.body.displayExp» end'''
			default: throw new Error("Invalid expression")
		}+")"
	}
	
		
}